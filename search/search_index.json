{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SCrOFit","text":"<p>Welcome to the official documentation of SCrOFit!</p>"},{"location":"#overview","title":"Overview","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Want to start using it immediately? Check out the Installation Guide.</p>"},{"location":"#tutorial-guide","title":"Tutorial Guide","text":"<p>The followings are tutorials of how to use SCrOFit:</p> <ul> <li>Run SMA data with SCrOFit</li> <li>Analyze SMA data after SCrOFit</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use SCrOFit in your research, please cite the following paper:</p> <p>APA format:</p> <pre><code>To be continued.\n</code></pre> <p>BibTeX format:</p> <pre><code>To be continued.\n</code></pre>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide explains how to install and configure SCrOFit.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installation, please ensure you have the following dependencies:</p> <ul> <li>Python &gt;= 3.12</li> <li>Other dependencies (if applicable)</li> </ul>"},{"location":"installation/#installation","title":"Installation","text":"<p>From GitHub (recommended for the latest version)</p> <pre><code>pip install git+https://github.com/compbioclub/SCrOFit.git\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<ol> <li>Vicari, M., Mirzazadeh, R., Nilsson, A. et al. Spatial multimodal analysis of transcriptomes and metabolomes in tissues. Nat Biotechnol 42, 1046\u20131050 (2024)</li> </ol>"},{"location":"tutorial/analysis_SMA_after_SCrOFit/","title":"Analyze SMA data after SCrOFit","text":"<p>This notebook demosntrate how to analyze the SMA data after running SCrOFit.</p> <pre><code>%load_ext autoreload\n</code></pre> <pre><code>%autoreload\nimport anndata as ad\nimport scanpy as sc\nimport matplotlib.pyplot as plt\nimport squidpy as sq\nimport numpy as np\n\nimport sys\nsys.path.append('../../')\nimport scrofit.plotting as pl\n\nsample = 'V11T17-102'\nin_dir = f'../../../data/MSA_data/{sample}'\n\nst_adata = ad.read_h5ad(f'{in_dir}/{sample}_st_pp.adata')\nsm_adata = ad.read_h5ad(f'{in_dir}/{sample}_sm_pp.adata')\nmdata = ad.read_h5ad(f'{in_dir}/{sample}_m_pp.adata')\n\n\nsm_adata.obsm['SMA\\nSM OCS'] = sm_adata.obsm['spatial']\nst_adata.obsm['SMA\\nST OCS'] = st_adata.obsm['spatial']\nsc.pl.spatial(st_adata, basis='SMA\\nST OCS')\n\n\n\nmymap = {'unk': np.nan, 'unk2': np.nan}\nst_adata.obs['Region'] = st_adata.obs['RegionLoupe'].apply(lambda x: mymap.get(x, x))\npl.ocs_spatial_scatter(st_adata, 'ST', color=['Region'], img=True, shape=None, library_id=sample,\n                      size=0.5,\n                      out_fn='ocs_region.pdf')\n\nmdata.obs['ST_Region'] = mdata.obs['ST_RegionLoupe'].apply(lambda x: mymap.get(x, x))\npl.ccs_spatial_scatter(mdata, 'ST', color=['ST_Region'], img=True, shape=None, library_id=sample,\n                      size=0.5,\n                      out_fn='ccs_region.pdf')\n\npl.embed(mdata, color='ST_Region', figsize=(2.8, 3),\n         out_fn='embed_reigon.pdf')\npl.ocs_spatial_scatter(st_adata, 'ST', color=['dopamine'], img=True, shape=None, library_id=sample,\n                      size=0.5, palette='Set2',\n                      out_fn='ocs_dopamine.pdf')\n\npl.ccs_spatial_scatter(mdata, 'ST', color=['ST_dopamine'], img=True, shape=None, library_id=sample,\n                       size=0.5, palette='Set2', \n                       out_fn='ccs_dopamine.pdf')\n</code></pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n/var/folders/0x/6vsm66sd6g3_gc636v4617km0000gn/T/ipykernel_76684/844954310.py:22: FutureWarning: Use `squidpy.pl.spatial_scatter` instead.\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre><code>sm_adata\n</code></pre> <pre>\n<code>AnnData object with n_obs \u00d7 n_vars = 15813 \u00d7 1538\n    obs: 'sample', 'block', 'n_genes', 'ST_RegionLoupe', 'ST_MSN.D2.PenkNeg_5', 'ST_MSN.D1.TacNeg_3', 'ST_MSN.D2_C_18', 'ST_MSN.D1.TacPosB_6', 'ST_MSN.D1.TacPosA_9', 'ST_MSN.D2.PenkPos_2', 'ST_ST_id', 'LY6H', 'THY1', 'VSNL1', 'PCDH11X', 'MBP', 'PLP1', 'CHN1', 'SYNPR', 'NCDN', 'MAP2', 'GDA', 'HPCAL4', 'RTN1', 'NNAT', 'TSPAN7', 'PEG10', 'SCG2', 'TF', 'CRYM', 'GFAP', 'MT1G'\n    uns: 'spatial'\n    obsm: 'XY_spatial_euclidean_dist', 'mappingflow_MCMF', 'spatial', 'spatial_MCMF_map', 'spatial_normalized', 'spatial_rir', 'spatial_rir_filtered', 'SMA\\nSM OCS'\n    layers: 'log1p', 'raw'</code>\n</pre> <pre><code>%autoreload\nfor color in st_adata.obs.columns:\n    if not color.startswith('MSN'):\n        continue\n    pl.ocs_spatial_scatter(st_adata, 'ST', color=color, img=True, shape=None, \n                          library_id=sample, cmap='OrRd', size=0.5,\n                          out_fn=f'ocs_{color}.pdf')\n</code></pre> <pre><code>%autoreload\nfor gene in ['SCG2', 'CHN1', 'NNAT', 'GFAP', 'MBP', 'TF', 'PLP1']:\n    pl.ocs_spatial_scatter(st_adata, 'ST', color=gene, img=True, shape=None, \n                          library_id=sample, cmap='Spectral_r', size=0.5,\n                          out_fn=f'ocs_{gene}.pdf')\n</code></pre> <pre><code>%autoreload\npl.ocs_spatial_scatter(sm_adata, 'SM', color='mz_674.2805', img=False, shape=None, library_id=sample,\n                      cmap='viridis', size=0.5,\n                      out_fn='ocs_mz_674.2805.pdf')\npl.ccs_spatial_scatter(mdata, 'SM', color='mz_674.2805', img=False, shape=None, library_id=sample,\n                      cmap='plasma', size=0.5,\n                      out_fn='ccs_mz_674.2805.pdf')\n\n\npl.embed(mdata, color='mz_674.2805', cmap='plasma', figsize=(3.2, 3), colorbar_loc='right',\n         out_fn='embed_mz_674.2805.pdf')\n</code></pre> <pre><code>%autoreload\n\npl.ocs_spatial_scatter(st_adata, 'ST', color=['Cell_Type'], img=True, shape=None, library_id=sample,\n                       palette='Accent', size=0.5,\n                       out_fn='ocs_cell_type.pdf')\npl.ccs_spatial_scatter(mdata, 'ST', color=['ST_Cell_Type'], img=True, shape=None, library_id=sample,\n                       palette='Accent', size=0.5,\n                       out_fn='ccs_cell_type.pdf')\n\npl.embed(mdata, color='ST_Cell_Type', palette='Accent', figsize=(2.8, 3),\n         out_fn='embed_cell_type.pdf')\n</code></pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre><code>st_adata.obsm\n</code></pre> <pre>\n<code>AxisArrays with keys: spatial, spatial_normalized, spatial_rir, spatial_rir_filtered, SMA\nST OCS</code>\n</pre> <pre><code>mdata.obsm\n</code></pre> <pre>\n<code>AxisArrays with keys: SM_XY_spatial_euclidean_dist, SM_mappingflow_MCMF, SM_spatial, SM_spatial_MCMF_map, SM_spatial_normalized, SM_spatial_rir, SM_spatial_rir_filtered, ST_spatial, ST_spatial_normalized, ST_spatial_rir, ST_spatial_rir_filtered, X_pca, X_umap</code>\n</pre> <pre><code>%autoreload\n\nx_min=35000\nx_max=x_min+5000\ny_min=35000\ny_max=y_min+5000\n\npl.ccs_spatial_zoom(\n    st_adata, mdata,\n    metabolite=\"mz_674.2805\",\n    cell_type_col=\"Cell_Type\",\n    st_coord_key=\"spatial_rir\",\n    sm_coord_key=\"SM_spatial_rir\",\n    cell_dot_size=250,\n    x_min=x_min, x_max=x_max, \n    y_min=y_min, y_max=y_max,\n    figsize=(4,4),\n    st_cmap=\"Accent\",\n    m_cmap='plasma',\n    out_fn='ccs_zoom_cell_type.pdf'\n)\n</code></pre> <pre>\n<code>&lt;string&gt;:20: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n</code>\n</pre> <pre><code>%autoreload\n\npl.ccs_spatial_zoom(\n    st_adata, mdata,\n    metabolite=\"mz_674.2805\",\n    cell_type_col=\"Region\",\n    st_coord_key=\"spatial_rir\",\n    sm_coord_key=\"SM_spatial_rir\",\n    cell_dot_size=250,\n    gene_dot_size=10,\n    x_min=x_min, x_max=x_max, \n    y_min=y_min, y_max=y_max,\n    figsize=(4,4),\n    st_cmap=None,\n    m_cmap='plasma',\n    out_fn='ccs_zoom_region.pdf'\n)\n</code></pre> <pre>\n<code>&lt;string&gt;:20: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n</code>\n</pre> <pre><code>%autoreload\nimport seaborn as sns\nimport pandas as pd\n\ndopamine = 'Dopamine (mz_674.2805)'\nmymap = {'unk': np.nan, 'unk2': np.nan}\nsm_adata.obs['Region'] = sm_adata.obs['ST_RegionLoupe'].apply(lambda x: mymap.get(x, x))\nmymap = st_adata.obs['Cell_Type'].to_dict()\nsm_adata.obs['Cell_Type'] = sm_adata.obs['ST_ST_id'].apply(lambda x: mymap[x])\nsm_adata.obs['New_Cell_Type']  = sm_adata.obs['Cell_Type'].apply(lambda x: np.nan if x in ['Inhib', 'Inhib_MSN'] else x)\ncustom_order = ['MSN', 'Mi.MiR.Ma', 'Astro', 'OPC', 'Oligo']\nsm_adata.obs['New_Cell_Type']  = sm_adata.obs['New_Cell_Type'].astype(pd.CategoricalDtype(categories=custom_order, ordered=True))\n\n\nsm_adata.obs[dopamine] = dict(zip(sm_adata.obs.index, sm_adata[:, 'mz_674.2805'].X.reshape(-1)))\n\ncompare_type = 'New_Cell_Type'\ncomparisons = [\n    (\"MSN\", \"Astro\"),    \n    (\"MSN\", \"Mi.MiR.Ma\"),    \n    (\"MSN\", \"OPC\"),    \n    (\"MSN\", \"Oligo\"),     \n]\nbase_colors = sns.color_palette('Accent', 8).as_hex()\npalette = dict(zip(np.sort(sm_adata.obs['Cell_Type'].dropna().unique()), base_colors[:3] + base_colors[-4:]))\npl.violin(sm_adata, compare_type, dopamine, comparisons,\n             fig_size=(3, 3), \n             palette=palette,\n             text_x_angle=20,\n             out_fn='violin_cell_type.pdf')\n</code></pre> <pre>\n<code>&lt;string&gt;:6: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/plotnine/ggplot.py:623: PlotnineWarning: Saving 3 x 3 in image.\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/plotnine/ggplot.py:624: PlotnineWarning: Filename: violin_cell_type.pdf\n</code>\n</pre> <pre><code>%autoreload\ncompare_type = 'Region'\ncomparisons = [\n    #(\"ACB\", \"CI\"),    \n    #(\"ACB\", \"Cd\"),    \n    (\"Cd\", \"CI\"),    \n]\npl.violin(sm_adata[sm_adata.obs['Region'] != 'ACB'], compare_type, dopamine, comparisons,\n             fig_size=(3, 3),\n             text_x_angle=90,\n             palette=sc.pl.palettes.default_20[1:],\n             out_fn='violin_region.pdf')\n</code></pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/plotnine/ggplot.py:623: PlotnineWarning: Saving 3 x 3 in image.\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/plotnine/ggplot.py:624: PlotnineWarning: Filename: violin_region.pdf\n</code>\n</pre> <pre><code>import pandas as pd\ndf = pd.read_csv('../../../data/MSA_data/corHstr_onlyCdSpots.csv', index_col=0)\nSMA_cor_df = df[(df['FDR'] &amp;lt; 0.05) &amp;amp; (df['rho'].abs() &amp;gt; 0.2)]\n\nSMA_cor_df['Region'] = 'Cd'\nSMA_cor_df['Method'] = 'SMA'\nSMA_cor_df\n</code></pre> <pre>\n<code>/var/folders/0x/6vsm66sd6g3_gc636v4617km0000gn/T/ipykernel_76684/3254590528.py:5: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n/var/folders/0x/6vsm66sd6g3_gc636v4617km0000gn/T/ipykernel_76684/3254590528.py:6: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n</code>\n</pre> dopamine gene rho Pvalue FDR sig corlabel InvLog10FDR Region Method 348 Dopamine NCDN 0.244814 8.910519e-101 1.517065e-97 PosCor NCDN 96.818996 Cd SMA 395 Dopamine HPCAL4 0.210742 1.407301e-74 1.198004e-71 PosCor HPCAL4 70.921542 Cd SMA 1550 Dopamine VSNL1 0.236569 4.872488e-94 6.787375e-91 PosCor VSNL1 90.168298 Cd SMA 2148 Dopamine CHN1 0.263871 2.375161e-117 1.819730e-113 PosCor CHN1 112.739993 Cd SMA 2290 Dopamine MAP2 0.200022 3.214671e-67 2.239018e-64 PosCor MAP2 63.649942 Cd SMA 2368 Dopamine SCG2 0.326443 4.317302e-182 6.615401e-178 PosCor SCG2 177.179444 Cd SMA 2845 Dopamine SYNPR 0.255258 1.098729e-109 3.367164e-106 PosCor SYNPR 105.472736 Cd SMA 3064 Dopamine TF -0.234649 1.659563e-92 2.119124e-89 NegCor TF 88.673844 Cd SMA 5685 Dopamine PEG10 0.229432 2.058726e-88 2.253275e-85 PosCor PEG10 84.647186 Cd SMA 6483 Dopamine LY6H 0.229322 2.504924e-88 2.558863e-85 PosCor LY6H 84.591953 Cd SMA 6715 Dopamine GDA 0.204074 5.952055e-70 4.343016e-67 PosCor GDA 66.362209 Cd SMA 8509 Dopamine THY1 0.250591 1.185839e-105 3.028434e-102 PosCor THY1 101.518782 Cd SMA 9885 Dopamine RTN1 0.205265 9.126335e-71 6.992142e-68 PosCor RTN1 67.155390 Cd SMA 10849 Dopamine CRYM 0.247718 3.268268e-103 7.154239e-100 PosCor CRYM 99.145437 Cd SMA 11027 Dopamine MT1G 0.212344 1.029377e-75 9.278317e-73 PosCor MT1G 72.032531 Cd SMA 11788 Dopamine GFAP -0.262491 4.203159e-116 2.146833e-112 NegCor GFAP 111.668202 Cd SMA 12343 Dopamine MBP -0.246967 1.403670e-102 2.688555e-99 NegCor MBP 98.570481 Cd SMA 13619 Dopamine NNAT 0.258008 4.219107e-112 1.616235e-108 PosCor NNAT 107.791496 Cd SMA 14392 Dopamine TSPAN7 0.239372 2.667464e-96 4.087356e-93 PosCor TSPAN7 92.388558 Cd SMA 14576 Dopamine PCDH11X 0.206412 1.480592e-71 1.194059e-68 PosCor PCDH11X 67.922974 Cd SMA 14624 Dopamine PLP1 -0.233789 7.979968e-92 9.405927e-89 NegCor PLP1 88.026598 Cd SMA 14768 Dopamine PNMA5 0.223717 4.790115e-84 4.587434e-81 PosCor PNMA5 80.338430 Cd SMA <pre><code>from scipy.stats import pearsonr\n\ndata_list = []\nfor region in sm_adata.obs['Region'].unique():    \n    df = sm_adata[sm_adata.obs['Region'] == region].obs\n    if df.shape[0] == 0:\n        continue\n    for gene in SMA_cor_df['gene'].tolist():\n        if gene not in df.columns:\n            continue\n        corr, p_value = pearsonr(df[dopamine], df[gene])\n        data_list.append((region, 'Dopamine', gene, corr, p_value))\ndf = pd.DataFrame(data_list, columns=['Region', 'dopamine', 'gene', 'rho', 'Pvalue'])\ndf['Method'] = 'SCRoFit'\nbench_cor_df = pd.concat([SMA_cor_df[df.columns], df])\nbench_cor_df['Type'] = bench_cor_df['Region'] + '(' + bench_cor_df['Method'] + ')'\nbench_cor_df['InvLog10Pvalue'] = -np.log10(bench_cor_df['Pvalue'])\n\nbench_cor_df = bench_cor_df[bench_cor_df['Pvalue'] &amp;lt; 0.05]\n\n\nfrom matplotlib.colors import Normalize\n\n# Normalize the color values to set the midpoint to zero\nz = bench_cor_df['rho']\nnorm = Normalize(vmin=-np.max(np.abs(z)), vmax=np.max(np.abs(z)))\n\n\nfig = plt.figure(figsize=(7, 1.8)) \nsns.scatterplot(\n    data=bench_cor_df.sort_values(by='rho'), \n    y=\"Type\", x=\"gene\", \n    #order=['Cd(SCRoFit)', 'Cd(SMA)', 'CI(SCRoFit)', 'ACB', 'SCRoFit'],\n    hue='rho', hue_norm=norm,\n    size='InvLog10Pvalue',\n    palette='coolwarm'\n)\nplt.xlabel(None)\nplt.xticks(rotation=45, ha='right')\nplt.ylabel(None)\nplt.legend().set_visible(False)  # Hide the legend\nplt.tight_layout()\nplt.show()\n</code></pre> <pre><code>from scipy.stats import pearsonr\n\ndata_list = []\nfor cell_type in sm_adata.obs['Cell_Type'].unique():    \n    df = sm_adata[sm_adata.obs['Cell_Type'] == cell_type].obs\n    if df.shape[0] == 0:\n        continue\n    for gene in SMA_cor_df['gene'].tolist():\n        if gene not in df.columns:\n            continue\n        corr, p_value = pearsonr(df[dopamine], df[gene])\n        data_list.append((cell_type, 'Dopamine', gene, corr, p_value))\ncor_df = pd.DataFrame(data_list, columns=['Cell Type', 'dopamine', 'gene', 'rho', 'Pvalue'])\ncor_df['Method'] = 'SCRoFit'\ncor_df = cor_df[cor_df['Pvalue'] &amp;lt; 0.05]\ncor_df['InvLog10Pvalue'] = -np.log10(cor_df['Pvalue'])\n\n\nfig = plt.figure(figsize=(7,3)) \nz = cor_df['rho']\nnorm = Normalize(vmin=-np.max(np.abs(z)), vmax=np.max(np.abs(z)))\n\nsns.scatterplot(\n    data=cor_df.sort_values(by='rho'), \n    y=\"Cell Type\", x=\"gene\", \n    #order=['Cd(SCRoFit)', 'Cd(SMA)', 'CI(SCRoFit)', 'ACB', 'SCRoFit'],\n    hue='rho', hue_norm=norm,\n    size='InvLog10Pvalue',\n    palette='coolwarm'\n)\nplt.xlabel(None)\nplt.ylabel(None)\nplt.xticks(rotation=45, ha='right')\nplt.legend().set_visible(False)  # Hide the legend\nplt.tight_layout()\nplt.show()\n</code></pre> <pre>\n<code>/var/folders/0x/6vsm66sd6g3_gc636v4617km0000gn/T/ipykernel_76684/3588643302.py:11: ConstantInputWarning: An input array is constant; the correlation coefficient is not defined.\n</code>\n</pre> <pre><code>bench_cor_df['Annotation'] = bench_cor_df['Region']\nbench_cor_df['Function Annotation'] = 'Region'\ncor_df['Annotation'] = cor_df['Cell Type']\ncor_df['Function Annotation'] = 'Cell Type'\n\ncols = ['Function Annotation', 'Annotation', 'dopamine', 'gene', 'rho', 'Pvalue', 'Method',\n       'InvLog10Pvalue']\ndf = pd.concat([bench_cor_df[cols], cor_df[cols]])\ndf = df.sort_values(by=['Function Annotation', 'Annotation', 'rho'], ascending=[False, True, True])\nz = df['rho']\nnorm = Normalize(vmin=-np.max(np.abs(z)), vmax=np.max(np.abs(z)))\n\nfig = plt.figure(figsize=(4,5)) \nsns.scatterplot(\n    data=df[df['Method'] == 'SCRoFit'], \n    x=\"Annotation\", y=\"gene\", \n    #order=['Cd(SCRoFit)', 'Cd(SMA)', 'CI(SCRoFit)', 'ACB', 'SCRoFit'],\n    hue='rho', hue_norm=norm,\n    size='InvLog10Pvalue',\n    palette='coolwarm'\n)\nplt.xlabel(None)\nplt.ylabel(None)\nplt.xticks(rotation=60, ha='right')\n#plt.legend().set_visible(False)  # Hide the legend\nplt.legend(loc=\"upper left\", bbox_to_anchor=(1, 1))\n#plt.tight_layout()\nplt.show()\n</code></pre> <pre><code>import pandas as pd\nimport numpy as np\nfrom plotnine import *\n\ndf = df.sort_values(\n    by=['Function Annotation', 'Annotation', 'rho'],\n    ascending=[False, True, True]\n).copy()\n\ndf['gene'] = pd.Categorical(df['gene'], categories=df['gene'].unique(), ordered=True)\ndf = df[df['Annotation'].isin(['CI', 'Cd', 'MSN', 'Astro', 'OPC', 'Oligo'])]\ndf['Annotation'] = pd.Categorical(df['Annotation'],categories=['CI', 'Cd', 'MSN', 'Astro', 'OPC', 'Oligo'],ordered=True)\n\nmax_abs = df['rho'].abs().max()\np = (\n    ggplot(df[df['Method'] == 'SCRoFit'],\n           aes(y='Annotation', x='gene',\n               color='rho',\n               size='InvLog10Pvalue'))\n    + facet_grid('Function Annotation ~ .', \n                 scales='free', space='free')\n    + geom_point()\n    + scale_color_gradient2(\n        low=\"blue\", mid=\"white\", high=\"red\",\n        midpoint=0,\n        limits=(-max_abs, max_abs)\n      )\n    + scale_size_area(max_size=5)\n    + theme_bw()\n    + theme(\n        figure_size=(5, 4),  \n        axis_text_y=element_text(angle=45, hjust=1),\n        axis_text_x=element_text(angle=90, hjust=-1),\n        strip_background=element_blank(),\n      )\n    + labs(\n        color='rho',\n        size='-log10(p)',\n        x='',\n        y=''\n      )   \n)\np.save('spatial_cor.pdf')\np\n</code></pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/plotnine/ggplot.py:623: PlotnineWarning: Saving 5 x 4 in image.\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/plotnine/ggplot.py:624: PlotnineWarning: Filename: spatial_cor.pdf\n</code>\n</pre> <pre><code>st_adata[st_adata.obs['Region'] == 'ACB'].obsm['spatial_rir'].copy().min(axis=0), \\\nst_adata[st_adata.obs['Region'] == 'ACB'].obsm['spatial_rir'].copy().max(axis=0)\n</code></pre> <pre>\n<code>(array([  5396, 107920]), array([ 42228, 157478]))</code>\n</pre> <pre><code>%autoreload\n\nx_min = 17000\nx_max = x_min + 5000\ny_min = 120000\ny_max = y_min + 5000\n# Usage example\npl.ccs_spatial_zoom(\n    st_adata, mdata,\n    metabolite=\"mz_674.2805\", \n    gene=\"GFAP\",\n    cell_type_col=\"Region\",\n    st_coord_key=\"spatial_rir\",\n    sm_coord_key=\"SM_spatial_rir\",\n    cell_dot_size=250,\n    gene_dot_size=10,\n    x_min=x_min, x_max=x_max, \n    y_min=y_min, y_max=y_max,\n    figsize=(4, 4),\n    st_cmap=None,\n    g_cmap='Spectral_r',\n    m_cmap='plasma',\n    out_fn='ccs_zoom_GFAP_region.pdf'\n)\n</code></pre> <pre>\n<code>&lt;string&gt;:20: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n</code>\n</pre> <pre><code>%autoreload\n\npl.plot_gene_cell_type(st_adata, mdata, 'GFAP', 'Region', 'ACB')\n</code></pre> <pre>\n<code>&lt;string&gt;:5: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:9: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n&lt;string&gt;:15: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n&lt;string&gt;:16: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n&lt;string&gt;:17: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n</code>\n</pre> <pre><code>print(st_adata[st_adata.obs['Region'] == 'CI'].obsm['spatial_rir'].copy().min(axis=0), \\\nst_adata[st_adata.obs['Region'] == 'CI'].obsm['spatial_rir'].copy().max(axis=0))\n\nx_min = 30120\nx_max = x_min + 5000\ny_min = 80000\ny_max = y_min + 5000\n\npl.ccs_spatial_zoom(\n    st_adata, mdata,\n    metabolite=\"mz_674.2805\", \n    gene=\"TF\",\n    cell_type_col=\"Region\",\n    st_coord_key=\"spatial_rir\",\n    sm_coord_key=\"SM_spatial_rir\",\n    cell_dot_size=250,\n    gene_dot_size=10,\n    x_min=x_min, x_max=x_max, \n    y_min=y_min, y_max=y_max,\n    figsize=(4, 4),\n    st_cmap=None,\n    g_cmap='Spectral_r',\n    m_cmap='plasma',\n    out_fn='ccs_zoom_CI_TF_mz_674.2805.pdf'\n)\n</code></pre> <pre>\n<code>[25120  3341] [ 42534 131249]\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:20: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n</code>\n</pre> <pre><code>%autoreload\npl.plot_gene_cell_type(st_adata, mdata, 'TF', 'Region', 'CI')\n</code></pre> <pre>\n<code>&lt;string&gt;:5: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:9: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n&lt;string&gt;:15: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n&lt;string&gt;:16: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n&lt;string&gt;:17: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n</code>\n</pre> <pre><code>%autoreload\npl.plot_gene_cell_type(st_adata, mdata, 'NCDN', 'Region', 'Cd')\n</code></pre> <pre>\n<code>&lt;string&gt;:5: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:9: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n&lt;string&gt;:15: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n&lt;string&gt;:16: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n&lt;string&gt;:17: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n</code>\n</pre> <pre><code>%autoreload\npl.plot_gene_cell_type(st_adata, mdata, 'SCG2', 'Region', 'Cd')\n</code></pre> <pre>\n<code>&lt;string&gt;:5: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:9: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n&lt;string&gt;:15: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n&lt;string&gt;:16: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n&lt;string&gt;:17: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n</code>\n</pre> <pre><code>%autoreload\nprint(st_adata[st_adata.obs['Cell_Type'] == 'Astro'].obsm['spatial_rir'].copy().min(axis=0), \\\nst_adata[st_adata.obs['Cell_Type'] == 'Astro'].obsm['spatial_rir'].copy().max(axis=0))\n\nx_min = 15000\nx_max = x_min + 5000\ny_min = 150000\ny_max = y_min + 5000\n# Usage example\npl.ccs_spatial_zoom(\n    st_adata, mdata,\n    metabolite=\"mz_674.2805\", \n    gene=\"MBP\",\n    cell_type_col=\"Cell_Type\",\n    st_coord_key=\"spatial_rir\",\n    sm_coord_key=\"SM_spatial_rir\",\n    cell_dot_size=250,\n    gene_dot_size=10,\n    x_min=x_min, x_max=x_max, \n    y_min=y_min, y_max=y_max,\n    figsize=(4, 4),\n    st_cmap='Accent',\n    g_cmap='Spectral_r',\n    m_cmap='plasma',\n    out_fn='ccs_zoom_Astro_MBP_mz_674.2805.pdf'\n)\n</code></pre> <pre>\n<code>[5256 3777] [ 42121 176669]\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:20: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n</code>\n</pre> <pre><code>%autoreload\npl.plot_gene_cell_type(st_adata, mdata, 'MBP', 'Cell_Type', 'Astro')\n</code></pre> <pre>\n<code>&lt;string&gt;:5: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:9: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n&lt;string&gt;:15: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n&lt;string&gt;:16: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n&lt;string&gt;:17: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n</code>\n</pre> <pre><code>%autoreload\npl.plot_gene_cell_type(st_adata, mdata, 'SCG2', 'Cell_Type', 'MSN')\n</code></pre> <pre>\n<code>&lt;string&gt;:5: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:9: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n&lt;string&gt;:15: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n&lt;string&gt;:16: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n&lt;string&gt;:17: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n</code>\n</pre> <pre><code>%autoreload\nprint(st_adata[st_adata.obs['Cell_Type'] == 'MSN'].obsm['spatial_rir'].copy().min(axis=0), \\\nst_adata[st_adata.obs['Cell_Type'] == 'MSN'].obsm['spatial_rir'].copy().max(axis=0))\n\nx_min = 25120  \nx_max = x_min + 5000\ny_min = 100000\ny_max = y_min + 5000\n# Usage example\npl.ccs_spatial_zoom(\n    st_adata, mdata,\n    metabolite=\"mz_674.2805\", \n    gene=\"NCDN\",\n    cell_type_col=\"Cell_Type\",\n    st_coord_key=\"spatial_rir\",\n    sm_coord_key=\"SM_spatial_rir\",\n    cell_dot_size=250,\n    gene_dot_size=10,\n    x_min=x_min, x_max=x_max, \n    y_min=y_min, y_max=y_max,\n    figsize=(4, 4),\n    st_cmap='Accent',\n    g_cmap='Spectral_r',\n    m_cmap='plasma',\n    out_fn='ccs_zoom_MSN_NCDN_mz_674.2805.pdf'\n)\n</code></pre> <pre>\n<code>[5373 3267] [ 42275 167991]\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:20: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n</code>\n</pre> <pre><code>%autoreload\npl.plot_gene_cell_type(st_adata, mdata, 'NCDN', 'Cell_Type', 'MSN')\n</code></pre> <pre>\n<code>&lt;string&gt;:5: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:9: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n&lt;string&gt;:15: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n&lt;string&gt;:16: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n&lt;string&gt;:17: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n</code>\n</pre> <pre><code>%autoreload\npl.plot_gene_cell_type(st_adata, mdata, 'PLP1', 'Cell_Type', 'Oligo')\n</code></pre> <pre>\n<code>&lt;string&gt;:5: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/squidpy/pl/_spatial_utils.py:976: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n</code>\n</pre> <pre>\n<code>&lt;string&gt;:9: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n&lt;string&gt;:15: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n&lt;string&gt;:16: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/scipy/sparse/_index.py:210: SparseEfficiencyWarning: Changing the sparsity structure of a csr_matrix is expensive. lil and dok are more efficient.\n&lt;string&gt;:17: ImplicitModificationWarning: Modifying `X` on a view results in data being overridden\n</code>\n</pre> <pre><code>bench_cor_df[bench_cor_df['gene'].isin(['GFAP', 'TF', 'NCDN', 'SCG2', 'MBP', 'PLP1'])]\n</code></pre> Region dopamine gene rho Pvalue Method Type InvLog10Pvalue Annotation Function Annotation 348 Cd Dopamine NCDN 0.244814 8.910519e-101 SMA Cd(SMA) 100.050097 Cd Region 2368 Cd Dopamine SCG2 0.326443 4.317302e-182 SMA Cd(SMA) 181.364788 Cd Region 3064 Cd Dopamine TF -0.234649 1.659563e-92 SMA Cd(SMA) 91.780006 Cd Region 11788 Cd Dopamine GFAP -0.262491 4.203159e-116 SMA Cd(SMA) 115.376424 Cd Region 12343 Cd Dopamine MBP -0.246967 1.403670e-102 SMA Cd(SMA) 101.852735 Cd Region 14624 Cd Dopamine PLP1 -0.233789 7.979968e-92 SMA Cd(SMA) 91.097999 Cd Region 0 Cd Dopamine NCDN 0.232060 1.737992e-94 SCRoFit Cd(SCRoFit) 93.759952 Cd Region 5 Cd Dopamine SCG2 0.192807 2.956723e-65 SCRoFit Cd(SCRoFit) 64.529189 Cd Region 7 Cd Dopamine TF -0.139372 1.220900e-34 SCRoFit Cd(SCRoFit) 33.913320 Cd Region 15 Cd Dopamine GFAP -0.125049 3.667300e-28 SCRoFit Cd(SCRoFit) 27.435654 Cd Region 16 Cd Dopamine MBP -0.178574 4.341583e-56 SCRoFit Cd(SCRoFit) 55.362352 Cd Region 20 Cd Dopamine PLP1 -0.151670 8.900975e-41 SCRoFit Cd(SCRoFit) 40.050562 Cd Region 21 CI Dopamine NCDN 0.040255 2.859989e-02 SCRoFit CI(SCRoFit) 1.543636 CI Region 26 CI Dopamine SCG2 0.129088 1.839477e-12 SCRoFit CI(SCRoFit) 11.735306 CI Region 28 CI Dopamine TF -0.503951 2.912170e-190 SCRoFit CI(SCRoFit) 189.535783 CI Region 36 CI Dopamine GFAP -0.453098 1.153272e-149 SCRoFit CI(SCRoFit) 148.938068 CI Region 37 CI Dopamine MBP -0.457587 5.602338e-153 SCRoFit CI(SCRoFit) 152.251631 CI Region 41 CI Dopamine PLP1 -0.475458 1.132699e-166 SCRoFit CI(SCRoFit) 165.945886 CI Region 42 ACB Dopamine NCDN 0.173216 1.763107e-12 SCRoFit ACB(SCRoFit) 11.753721 ACB Region 47 ACB Dopamine SCG2 0.133786 5.637002e-08 SCRoFit ACB(SCRoFit) 7.248952 ACB Region 49 ACB Dopamine TF -0.211509 5.436318e-18 SCRoFit ACB(SCRoFit) 17.264695 ACB Region 57 ACB Dopamine GFAP -0.558419 1.059766e-134 SCRoFit ACB(SCRoFit) 133.974790 ACB Region 58 ACB Dopamine MBP -0.292058 1.629507e-33 SCRoFit ACB(SCRoFit) 32.787944 ACB Region 62 ACB Dopamine PLP1 -0.144015 4.935206e-09 SCRoFit ACB(SCRoFit) 8.306695 ACB Region"},{"location":"tutorial/run_SCrOFit_SMA/","title":"Run SMA data with SCrOFit","text":"<p>This notebook demosntrate how to use SCrOFit to run SMA data.</p> <pre><code>%autoreload\n\nimport anndata as ad\nimport os\nimport pandas as pd\n\nimport sys\nsys.path.append('../../')\n\nfrom scrofit.scrofit import SCrOFit\n\ndf = pd.read_csv('../../../data/MSA_data/corHstr_onlyCdSpots.csv', index_col=0)\nSMA_cor_df = df[(df['FDR'] &amp;lt; 0.05) &amp;amp; (df['rho'].abs() &amp;gt; 0.2)]\n\n\ndef run_align(in_dir, sample):\n\n    st_adata = ad.read_h5ad(f'{in_dir}/{sample}_st_raw.adata')\n    sm_adata = ad.read_h5ad(f'{in_dir}/{sample}_sm_raw.adata')\n    adata_dict = {'ST': st_adata, 'SM': sm_adata}\n\n    out_dir = os.path.join(in_dir, 'scrofit_out')\n\n    obj = SCrOFit(adata_dict=adata_dict, out_dir=out_dir, sample=sample)\n\n    obj.align_slides()\n\n    print('---start mapping---')\n    obj.mapping(mapping_method='MCMF', ccs_type='spatial_rir',\n                alpha=1, beta=1, n_neighbors=3,\n                n_thread=6, n_batch=250,\n                verbose=False)  \n\n    obj.check_slides()\n\n    headers = ['RegionLoupe', 'MSN.D2.PenkPos_2', 'MSN.D1.TacNeg_3', 'MSN.D2.PenkNeg_5',\n               'MSN.D1.TacPosB_6', 'MSN.D1.TacPosA_9', 'MSN.D2_C_18'] + SMA_cor_df['gene'].tolist()\n    obj.transfer_anno(headers)\n\n    for key, adata in adata_dict.items():\n        fn = '{}/{}_{}_pp.adata'.format(in_dir, sample, key.lower())\n        adata.write_h5ad(fn)\n\n    return obj, adata_dict\n\nobj_dict = {}\nfor sample in ['V11T17-102']:\n    for block in ['A1', 'B1', 'C1', 'D1']:\n        print(block)\n        in_dir = f'../../../data/MSA_data/{sample}'\n        obj, adata_dict = run_align(in_dir, sample + '_' + block)\n        obj_dict[block] = obj\n</code></pre> <pre><code>%autoreload\n\nimport anndata as ad\nimport os\nimport numpy as np\nfrom scrofit.mapping import init_mdata\n\ndef merge_celltype(st_adata):\n    cell_types = [\"Astro_0\",\"Oligo_1\",\"MSN.D2.PenkPos_2\",\"MSN.D1.TacNeg_3\",\"Oligo_4\",\"MSN.D2.PenkNeg_5\",\n    \"MSN.D1.TacPosB_6\",\"OPC_7\",\"Mi.MiR.Ma_8\",\"MSN.D1.TacPosA_9\",\"Astro_10\",\"Astro_11\",\"Inhib_MSN_12\",\n    \"Inhib_13\",\"unk_14\",\"unk_15\",\"unk_16\",\"Astro_17\",\"MSN.D2_C_18\",\"unk_19\",\"OPC_20\",\"Oligo_21\",\"unk_22\"]\n    X = st_adata.obs[cell_types].to_numpy()\n    st_adata.obs['Cell Type'] = np.array(cell_types)[X.argmax(axis=1)]\n    st_adata.obs['Cell Type'] = st_adata.obs['Cell Type'].apply(lambda x: '_'.join(x.split('_')[:-1]))\n    st_adata.obs['Cell Type'] = st_adata.obs['Cell Type'].apply(lambda x: np.nan if x == 'unk' else x)\n    mymap = {\n        'MSN.D2.PenkNeg': 'MSN',\n        'MSN.D1.TacPosB': 'MSN', \n        'MSN.D1.TacPosA': 'MSN', \n        'MSN.D2.PenkPos': 'MSN', \n        'MSN.D1.TacNeg': 'MSN',  \n        'MSN.D2_C': 'MSN', \n    }\n    st_adata.obs['Cell_Type']  =st_adata.obs['Cell Type'].apply(lambda x: mymap.get(x, x))\n\n\ndef replace_y_coord(in_dir, sample, block, i):\n    st_adata = ad.read_h5ad(f'{in_dir}/{sample}_{block}_st_pp.adata')\n    sm_adata = ad.read_h5ad(f'{in_dir}/{sample}_{block}_sm_pp.adata')\n\n    for key in  ['spatial_rir', 'spatial_rir_filtered', 'spatial_MCMF_map', 'spatial']:\n        if key in st_adata.obsm:\n            st_adata.obsm[key][:, 1] += 45000*i\n            print(sample, key, 'ST', st_adata.obsm[key][:, 1].min(), st_adata.obsm[key][:, 1].max())\n        if key in sm_adata.obsm:\n            if key == 'spatial':\n                sm_adata.obsm[key][:, 1] += 70*i\n            else:\n                sm_adata.obsm[key][:, 1] += 45000*i\n            print(sample, key, 'ST', sm_adata.obsm[key][:, 1].min(), sm_adata.obsm[key][:, 1].max())\n\n    return st_adata, sm_adata\n\nst_adata_list, sm_adata_list = [], []\nmdata_list = []\nfor sample in ['V11T17-102']:\n    image_list = []\n    for i, block in enumerate(['A1', 'B1', 'C1', 'D1']):\n        in_dir = f'../../../data/MSA_data/{sample}'\n        st_adata, sm_adata = replace_y_coord(in_dir, sample, block, i)\n        merge_celltype(st_adata)\n\n        st_adata_list.append(st_adata)\n        sm_adata_list.append(sm_adata)\n\n        image = st_adata.uns['spatial'][f'{sample}_{block}']['images']['hires']\n        scalefactors = st_adata.uns['spatial'][f'{sample}_{block}']['scalefactors']\n\n        image_list.append(image)\n\n        #for col in sm_adata.obs.columns:\n        #    if col.startswith('ST'):\n        #        del sm_adata.obs[col]\n        mdata = init_mdata(sm_adata, st_adata)  \n        mdata_list.append(mdata)\n\n\n    st_adata = ad.concat(st_adata_list)\n    print(st_adata_list[0].uns['spatial'][f'{sample}_A1']['scalefactors'])\n    print(st_adata_list[1].uns['spatial'][f'{sample}_B1']['scalefactors'])\n    print(st_adata_list[2].uns['spatial'][f'{sample}_C1']['scalefactors'])\n    print(st_adata_list[3].uns['spatial'][f'{sample}_D1']['scalefactors'])    \n    st_adata.uns['spatial'] = {sample:{\n        'images': {'hires': np.concatenate(image_list)},\n        'scalefactors': scalefactors\n        }}\n\n    sm_adata = ad.concat(sm_adata_list)\n    sm_adata.uns['spatial'] = {sample:{'images': {'hires': np.concatenate(image_list)}}}\n\n    mdata = ad.concat(mdata_list)\n\n\n    st_adata.write_h5ad(f'{in_dir}/{sample}_st_pp.adata')\n    sm_adata.write_h5ad(f'{in_dir}/{sample}_sm_pp.adata')\n</code></pre> <pre>\n<code>V11T17-102 spatial_rir ST 3267 41826\nV11T17-102 spatial_rir ST 3559.905021567236 40827.900430471855\nV11T17-102 spatial_rir_filtered ST 3267 41826\nV11T17-102 spatial_rir_filtered ST nan nan\nV11T17-102 spatial_MCMF_map ST nan nan\nV11T17-102 spatial ST 3267 41826\nV11T17-102 spatial ST 0 64\nV11T17-102 spatial_rir ST 47834 86785\nV11T17-102 spatial_rir ST 48144.84619771383 85815.9645796817\nV11T17-102 spatial_rir_filtered ST 47834 86785\nV11T17-102 spatial_rir_filtered ST nan nan\nV11T17-102 spatial_MCMF_map ST nan nan\nV11T17-102 spatial ST 47834 86785\nV11T17-102 spatial ST 70 134\nV11T17-102 spatial_rir ST 92762 131250\nV11T17-102 spatial_rir ST 92999.24074128651 130552.32918017515\nV11T17-102 spatial_rir_filtered ST 92762 131250\nV11T17-102 spatial_rir_filtered ST nan nan\nV11T17-102 spatial_MCMF_map ST nan nan\nV11T17-102 spatial ST 92762 131250\nV11T17-102 spatial ST 140 204\nV11T17-102 spatial_rir ST 137673 176669\nV11T17-102 spatial_rir ST 137570.2394988102 177668.60153934648\nV11T17-102 spatial_rir_filtered ST 137673 176669\nV11T17-102 spatial_rir_filtered ST nan nan\nV11T17-102 spatial_MCMF_map ST nan nan\nV11T17-102 spatial ST 137673 176669\nV11T17-102 spatial ST 210 275\n{'fiducial_diameter_fullres': np.float64(610.9539999999998), 'spot_diameter_fullres': np.float64(378.20962999999995), 'tissue_hires_scalef': np.float64(0.04111842), 'tissue_lowres_scalef': np.float64(0.012335527)}\n{'fiducial_diameter_fullres': np.float64(609.50275), 'spot_diameter_fullres': np.float64(377.31122), 'tissue_hires_scalef': np.float64(0.04111842), 'tissue_lowres_scalef': np.float64(0.012335527)}\n{'fiducial_diameter_fullres': np.float64(609.6982399999999), 'spot_diameter_fullres': np.float64(377.43224999999995), 'tissue_hires_scalef': np.float64(0.04111842), 'tissue_lowres_scalef': np.float64(0.012335527)}\n{'fiducial_diameter_fullres': np.float64(609.4973), 'spot_diameter_fullres': np.float64(377.30785999999995), 'tissue_hires_scalef': np.float64(0.04111842), 'tissue_lowres_scalef': np.float64(0.012335527)}\n</code>\n</pre> <pre>\n<code>/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/aligned_df.py:68: ImplicitModificationWarning: Transforming to str index.\n/Users/chenlingxi/miniconda3/envs/dev/lib/python3.11/site-packages/anndata/_core/anndata.py:1756: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.\n</code>\n</pre> <pre><code>mdata\n</code></pre> <pre>\n<code>AnnData object with n_obs \u00d7 n_vars = 15813 \u00d7 13934\n    obs: 'SM_index', 'SM_sample', 'SM_block', 'SM_n_genes', 'SM_ST_RegionLoupe', 'SM_ST_MSN.D2.PenkNeg_5', 'SM_ST_MSN.D1.TacNeg_3', 'SM_ST_MSN.D2_C_18', 'SM_ST_MSN.D1.TacPosB_6', 'SM_ST_MSN.D1.TacPosA_9', 'SM_ST_MSN.D2.PenkPos_2', 'SM_ST_ST_id', 'SM_LY6H', 'SM_THY1', 'SM_VSNL1', 'SM_PCDH11X', 'SM_MBP', 'SM_PLP1', 'SM_CHN1', 'SM_SYNPR', 'SM_NCDN', 'SM_MAP2', 'SM_GDA', 'SM_HPCAL4', 'SM_RTN1', 'SM_NNAT', 'SM_TSPAN7', 'SM_PEG10', 'SM_SCG2', 'SM_TF', 'SM_CRYM', 'SM_GFAP', 'SM_MT1G', 'ST_index', 'ST_in_tissue', 'ST_array_row', 'ST_array_col', 'ST_dopamine', 'ST_cell_type', 'ST_sample', 'ST_block', 'ST_orig.ident', 'ST_nCount_RNA', 'ST_nFeature_RNA', 'ST_Protocol', 'ST_Path.To.File', 'ST_File.Name', 'ST_Data.Type', 'ST_Glass.Type', 'ST_ArrayID', 'ST_Sample.ID', 'ST_Matrix', 'ST_Laser', 'ST_Laser.resolution', 'ST_Condition', 'ST_Brain.area', 'ST_Visium.Protocol', 'ST_id', 'ST_labels', 'ST_Prot.Short', 'ST_section_number', 'ST_type', 'ST_type.area', 'ST_lesion', 'ST_region', 'ST_RegionLoupe', 'ST_percent.mito', 'ST_percent.ribo', 'ST_Astrocytes', 'ST_Cerebellum.neurons', 'ST_Cholinergic.and.monoaminergic.neurons', 'ST_Cholinergic.and.monoaminergic.neurons.MBDOP1', 'ST_Cholinergic.and.monoaminergic.neurons.MBDOP2', 'ST_Choroid.epithelial.cells', 'ST_Dentate.gyrus.granule.neurons', 'ST_Dentate.gyrus.radial.glia.like.cells', 'ST_Di..and.mesencephalon.excitatory.neurons', 'ST_Di..and.mesencephalon.inhibitory.neurons', 'ST_Enteric.glia', 'ST_Enteric.neurons', 'ST_Ependymal.cells', 'ST_Glutamatergic.neuroblasts', 'ST_Hindbrain.neurons', 'ST_Microglia', 'ST_Non.glutamatergic.neuroblasts', 'ST_Olfactory.ensheathing.cells', 'ST_Olfactory.inhibitory.neurons', 'ST_Olfactory.inhibitory.neurons.OBDOP1', 'ST_Olfactory.inhibitory.neurons.OBDOP2', 'ST_Oligodendrocyte.precursor.cells', 'ST_Oligodendrocytes', 'ST_Peptidergic.neurons', 'ST_Pericytes', 'ST_Peripheral.sensory.neurofilament.neurons', 'ST_Peripheral.sensory.non.peptidergic.neurons', 'ST_Peripheral.sensory.peptidergic.neurons', 'ST_Perivascular.macrophages', 'ST_Satellite.glia', 'ST_Schwann.cells', 'ST_Spinal.cord.excitatory.neurons', 'ST_Spinal.cord.inhibitory.neurons', 'ST_Subcommissural.organ.hypendymal.cells', 'ST_Subventricular.zone.radial.glia.like.cells', 'ST_Sympathetic.cholinergic.neurons', 'ST_Sympathetic.noradrenergic.neurons', 'ST_Telencephalon.inhibitory.interneurons', 'ST_Telencephalon.projecting.excitatory.neurons', 'ST_Telencephalon.projecting.inhibitory.neurons.MSN1', 'ST_Telencephalon.projecting.inhibitory.neurons.MSN2', 'ST_Telencephalon.projecting.inhibitory.neurons.MSN3', 'ST_Telencephalon.projecting.inhibitory.neurons.MSN4', 'ST_Telencephalon.projecting.inhibitory.neurons.MSN5', 'ST_Telencephalon.projecting.inhibitory.neurons.MSN6', 'ST_Vascular.and.leptomeningeal.cells', 'ST_Vascular.endothelial.cells', 'ST_Vascular.smooth.muscle.cells', 'ST_nCount_SCT', 'ST_nFeature_SCT', 'ST_Astro_0', 'ST_Oligo_1', 'ST_MSN.D2.PenkPos_2', 'ST_MSN.D1.TacNeg_3', 'ST_Oligo_4', 'ST_MSN.D2.PenkNeg_5', 'ST_MSN.D1.TacPosB_6', 'ST_OPC_7', 'ST_Mi.MiR.Ma_8', 'ST_MSN.D1.TacPosA_9', 'ST_Astro_10', 'ST_Astro_11', 'ST_Inhib_MSN_12', 'ST_Inhib_13', 'ST_unk_14', 'ST_unk_15', 'ST_unk_16', 'ST_Astro_17', 'ST_MSN.D2_C_18', 'ST_unk_19', 'ST_OPC_20', 'ST_Oligo_21', 'ST_unk_22', 'ST_barcode', 'ST_library', 'ST_n_genes', 'SM_i', 'ST_i'\n    obsm: 'SM_XY_spatial_euclidean_dist', 'SM_mappingflow_MCMF', 'SM_spatial', 'SM_spatial_MCMF_map', 'SM_spatial_normalized', 'SM_spatial_rir', 'SM_spatial_rir_filtered', 'ST_spatial', 'ST_spatial_normalized', 'ST_spatial_rir', 'ST_spatial_rir_filtered'\n    layers: 'log1p', 'raw'</code>\n</pre> <pre><code>%autoreload\nfrom scrofit.embedding import embedding\n\nembedding(mdata)\nmdata.write_h5ad(f'{in_dir}/{sample}_m_pp.adata')\n</code></pre>"}]}